Boolean nets are Petri nets that permit at most one token per place. Research has approached this
important subject in many ways which resulted in various different classes of boolean nets. But
yet, they are only distinguished by the allowed interactions between places and transitions, that
is, the possible effects of firing transitions. There are eight different interactions: no operation
(nop), input (inp), output (out), set, reset (res), swap, test of occupation (used), and test of
disposability (free). Considering every combination for a possible net class yields 256 boolean
classes in total. The synthesis problem for a particular class is to take an automaton A and compute
a boolean net of that class that has a state graph isomorphic to A. To the best of our knowledge, the
computational complexity of this problem has been analyzed for just two of the 256 classes, namely
elementary nets systems (nop, inp, out), where the problem is NP-hard, and flip-flop nets (nop,
inp, out, swap), which are synthesizable in polynomial time. However, depending on the desired
net features, like read-only places, exception handling, or hierarchy, one has to synthesize nets
with other interactions as for instance contextual nets (nop, inp, out, used, free) or trace nets
(nop, inp, out, set, res, used, free). The contribution of this paper is a thorough investigation
of the synthesis complexity for the 128 boolean net classes that allow nop. Our main result is a general
proof scheme that identifies 77 NP-hard cases. All remaining 51 classes are shown to be synthesizable
in polynomial time where 35 of them turn out to be trivial. 