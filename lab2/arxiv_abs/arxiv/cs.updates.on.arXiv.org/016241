Consider a channel that is capable of corrupting the data that is transmitted through it. In its standard
form, the channel coding problem asks for an encoding function mapping messages to codewords that
makes communication over the given channel resilient to a given noise level. This means that when
a codeword is sent over the channel, the receiver is able to recover it from a noisy version, provided
the added noise is below some bound. We study a stronger type of code, called a universal code. A universal
code is an encoding that is resilient to a given noise level for every channel and that, moreover,
works without knowing the channel. In contrast to encoding, the decoding function knows the type
of channel. We allow the encoding and the decoding functions to share randomness, which is unavailable
to the channel. For a universal code, there are two parameters of interest: the rate, which is the
ratio between the message length and the codeword length, and the number of shared random bits. There
are two scenarios for the type of attack that a channel can perform. In the oblivious scenario, the
channel adds noise based on the message and the encoding function but does not know the codeword.
In the Hamming scenario, the channel knows the codeword and is fully adversarial. We show the existence
in both scenarios of universal codes with rate converging to the optimal value as n grows, where n
is the codeword length. The number of shared random bits is O(log n) in the oblivious scenario, and
O(n) in the Hamming scenario, which, for typical values of the noise level, we show to be optimal,
modulo the constant hidden in the O() notation. In both scenarios, the universal encoding is done
in time polynomial in n, but the channel-dependent decoding procedures are not efficient. 