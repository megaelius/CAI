One of the most fundamental problems in Computer Science is the Knapsack problem. Given a set of n
items with different weights and values, it asks to pick the most valuable subset whose total weight
is below a capacity threshold T. Despite its wide applicability in various areas in Computer Science,
Operations Research, and Finance, the best known running time for the problem is O(Tn). The main
result of our work is an improved algorithm running in time O(TD), where D is the number of distinct
weights. Previously, faster runtimes for Knapsack were only possible when both weights and values
are bounded by M and V respectively, running in time O(nMV) [Pisinger'99]. In comparison, our algorithm
implies a bound of O(nM^2) without any dependence on V, or O(nV^2) without any dependence on M. Additionally,
for the unbounded Knapsack problem, we provide an algorithm running in time O(M^2) or O(V^2). Both
our algorithms match recent conditional lower bounds shown for the Knapsack problem [Cygan et al'17,
K\"unnemann et al'17]. We also initiate a systematic study of general capacitated dynamic programming,
of which Knapsack is a core problem. This problem asks to compute the maximum weight path of length
k in an edge- or node-weighted directed acyclic graph. In a graph with m edges, these problems are
solvable by dynamic programming in time O(km), and we explore under which conditions the dependence
on k can be eliminated. We identify large classes of graphs where this is possible and apply our results
to obtain linear time algorithms for the problem of k-sparse Delta-separated sequences. The main
technical innovation behind our results is identifying and exploiting concavity that appears
in relaxations and subproblems of the tasks we consider. 