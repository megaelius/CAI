Smart contracts are an innovation built on top of the blockchain technology. It provides a platform
for automatically executing contracts in an anonymous, distributed, and trusted way. The most
popular programming language for creating smart contracts is called Solidity, which is supported
by Ethereum. Like ordinary programs, Solidity programs may contain vulnerabilities, which potentially
lead to attacks. The problem is magnified by the fact that smart contracts, unlike ordinary programs,
cannot be patched easily once deployed. It is thus important that smart contracts are checked against
potential vulnerabilities. Existing approaches tackle the problem by developing methods which
aim to automatically verify smart contracts. Such approaches often results in false alarms or poor
scalability, fundamentally because Solidity is Turing-complete. In this work, we propose an alternative
approach to automatically identify critical program paths (with multiple function calls including
inter-contract function calls) in a smart contract, rank the paths according to their criticalness,
discard them if they are infeasible or otherwise present them with user friendly warnings for user
inspection. We identify paths which involve monetary transaction as critical paths, and prioritize
those which potentially violate important properties. For scalability, symbolic execution techniques
are only applied to top ranked critical paths. Our approach has been implemented in a tool called
sCompile, which has been applied to 36,099 smart contracts. The experiment results show that sCompile
is efficient, i.e., 5 seconds on average for one smart contract. Furthermore, we show that many known
vulnerability can be captured if the user inspects as few as 10 program paths generated by sCompile.
Lastly, sCompile discovered 224 unknown vulnerabilities with a false positive rate of 15.4% before
user inspection. 