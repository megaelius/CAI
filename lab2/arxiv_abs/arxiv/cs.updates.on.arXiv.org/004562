Among the fundamental questions in computer science, at least two have a deep impact on mathematics.
What can computation compute? How many steps does a computation require to solve an instance of the
3-SAT problem? Our work addresses the first question, by introducing a new model called the x-machine.
The x-machine executes Turing machine instructions and two special types of instructions. Quantum
random instructions are physically realizable with a quantum random number generator. Meta instructions
can add new states and add new instructions to the x-machine. A countable set of x-machines is constructed,
each with a finite number of states and instructions; each x-machine can compute a Turing incomputable
language, whenever the quantum randomness measurements behave like unbiased Bernoulli trials.
In 1936, Alan Turing posed the halting problem for Turing machines and proved that this problem is
unsolvable for Turing machines. Consider an enumeration E_a(i) = (M_i, T_i) of all Turing machines
M_i and initial tapes T_i. Does there exist an x-machine X that has at least one evolutionary path
X --> X_1 --> X_2 --> . . . --> X_m, so at the mth stage x-machine X_m can correctly determine for 0 <= i
<= m whether M_i's execution on tape T_i eventually halts? We demonstrate an x-machine Q(x) that
has one such evolutionary path. The existence of this evolutionary path suggests that David Hilbert
was not misguided to propose in 1900 that mathematicians search for finite processes to help construct
mathematical proofs. Our refinement is that we cannot use a fixed computer program that behaves
according to a fixed set of mechanical rules. We must pursue methods that exploit randomness and
self-modification so that the complexity of the program can increase as it computes. 