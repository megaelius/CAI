Context: Computational notebooks are a contemporary style of literate programming, in which users
can communicate and transfer knowledge by interleaving executable code, output, and prose in a
single rich document. A Domain-Specific Language (DSL) is an artificial software language tailored
for a particular application domain. Usually, DSL users are domain experts that may not have a software
engineering background. As a consequence, they might not be familiar with Integrated Development
Environments (IDEs). Thus, the development of tools that offer different interfaces for interacting
with a DSL is relevant. Inquiry: However, resources available to DSL designers are limited. We would
like to leverage tools used to interact with general purpose languages in the context of DSLs. Computational
notebooks are an example of such tools. Then, our main question is: What is an efficient and effective
method of designing and implementing notebook interfaces for DSLs? By addressing this question
we might be able to speed up the development of DSL tools, and ease the interaction between end-users
and DSLs. Approach: In this paper, we present Bacat\'a, a mechanism for generating notebook interfaces
for DSLs in a language parametric fashion. We designed this mechanism in a way in which language engineers
can reuse as many language components (e.g., language processors, type checkers, code generators)
as possible. Knowledge: Our results show that notebook interfaces generated by Bacat\'a can be
automatically generated with little manual configuration. There are few considerations and caveats
that should be addressed by language engineers that rely on language design aspects. The creation
of a notebook for a DSL with Bacat\'a becomes a matter of writing the code that wires existing language
components in the Rascal language workbench with the Jupyter platform. Grounding: We evaluate
Bacat\'a by generating functional computational notebook interfaces for three different non-trivial
DSLs, namely: a small subset of Halide (a DSL for digital image processing), SweeterJS (an extended
version of JavaScript), and QL (a DSL for questionnaires). Additionally, it is relevant to generate
notebook implementations rather than implementing them manually. We measured and compared the
number of Source Lines of Code (SLOCs) that we reused from existing implementations of those languages.
Importance: The adoption of notebooks by novice-programmers and end-users has made them very popular
in several domains such as exploratory programming, data science, data journalism, and machine
learning. Why are they popular? In (data) science, it is essential to make results reproducible
as well as understandable. However, notebooks are only available for GPLs. This paper opens up the
notebook metaphor for DSLs to improve the end-user experience when interacting with code and to
increase DSLs adoption. 